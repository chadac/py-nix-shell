{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"py-nix-shell","text":"<p>Power tool for provisioning Nix shells for Python. This makes Nix accessible and easy-to-use for Python devs while enabling Nix power users to leverage advanced caching capabilities with pure eval.</p>"},{"location":"#uses","title":"Uses","text":"<ul> <li>As a Nix shell   builder:   Write <code>shell.py</code> files to leverage the advantages of pure Nix shells   without losing impure features, such as customizing with environment   variables or using other forms of logic to maintain a Nix shell</li> <li>As a Python library: Provides a <code>subprocess</code>-like interface to   run regular CLI commands inside a nix shell; migrating existing   tooling is as simple as replacing <code>subprocess.run</code> with   <code>nix_shell.run</code>.</li> <li>As a shell wrapper: You can immediately set up any   pip-distributed CLI utilities to run inside a nix shell using   <code>shell.activate()</code>.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install nix-shell\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>See the docs for more details. Some example uses:</p>"},{"location":"#development-environments","title":"Development environments","text":"<p>Similar to Nix's <code>shell.nix</code>, you can build Nix shells inside a <code>shell.py</code> instead. For example:</p> <pre><code>import nix_shell\n\n# the `shell.py` needs to export a `shell` variable\nshell = nix_shell.mk_shell(packages=[\"uv\", \"mise\", \"curl\"], library_path=[\"zlib\"])\n\n# save shell metadata to the virtual environment to make reloading nearly instant\nshell.persist_venv()\n</code></pre> <p>Shells can be activated via the cli utility:</p> <pre><code>py-nix-shell activate # activate the given shell\npy-nix-shell print-den-env # useful for direnv-type activations\n</code></pre> <p>You can create Nix shells using a variety of builders:</p> <pre><code>import nix_shell\n\n# build a shell manually\nshell = nix_shell.mk_shell(packages=[\"curl\"], library_path=[\"stdenv.cc.cc.lib\"])\n\n# specify a shell.nix file to use\nshell = nix_shell.from_nix(\"path:/to/my/shell.nix\")\n\n# specify a flake to use\nshell = nix_shell.from_flake(\"path:/to/my/flake.nix#devShells.default\")\n</code></pre>"},{"location":"#subprocess-execution","title":"Subprocess execution","text":"<p><code>py-nix-shell</code> provides an interface that supports nearly all <code>subprocess</code> commands, but enables running them inside a Nix wrapper. Usage is as simple as:</p> <pre><code>import nix_shell\n\n# nix_shell supports existing subprocess commands\n\n# if the command name matches the `nixpkgs` name, install that by default\nnix_shell.run([\"curl\", \"https://google.com\", \"--insecure\"])\n\n# you can manually specify nix packages to install\nnix_shell.run([\"curl\", \"https://google.com\"], packages=[\"curl\", \"openssl\"])\n\n# use a dev environment from a flake\nnix_shell.run([\"curl\", \"https://google.com\"], flake=\"github:chadac/py-nix-shell#sample-curl-env\")\n\n# or, just use the `nixpkgs` version from a `flake.lock` file\nnix_shell.run([\"curl\", \"https://google.com\"], packages=[\"curl\", \"openssl\"], flake_lock=Path(\"./my/flake.lock\"))\n\n# it is also possible to reuse the same shell for multiple commands\nshell = nix_shell.mk_shell(packages=[\"curl\", \"openssl\"])\nshell.run([\"curl\", \"https://google.com\"])\nshell.run([\"curl\", \"https://yahoo.com\"])\n</code></pre> <p>You can use <code>run</code>, <code>check_output</code>, <code>Popen</code>, <code>call</code>, <code>check_call</code>, <code>getoutput</code> and <code>getstatusoutput</code>.</p>"},{"location":"#cli-wrappers","title":"CLI wrappers","text":"<p>The same shell builders also provide an <code>activate</code> script which will update your current Python session to use the Nix environment, similarly to running it as if it were spawned by <code>nix shell</code>:</p> <pre><code>import subprocess\nimport nix_shell\nshell = nix_shell.mk_shell(packages=[\"curl\", \"openssl\"])\n\ndef cli():\n    shell.activate()\n    subprocess.run([\"which\", \"curl\"]) # will point to the Nix version\n</code></pre>"},{"location":"advanced/","title":"Advanced Usage","text":""},{"location":"advanced/#pure-evaluation","title":"Pure evaluation","text":"<p><code>py-nix-shell</code> encourages pure Nix evaluation -- in other words, it explicitly declares the versions of inputs used up-front and disables impure evaluation capabilities like accessing environment variables or random files on your filesystem while writing Nix code.</p> <p>This is largely because when your evaluation is pure, it's a whole lot easier to cache the result of Nix shells and quickly access the results of those caches without much additional specification.</p> <p>It is possible to supplement impure requirements in your Nix files. For example, if you wanted to pass certain environment variables to a <code>shell.nix</code>, you could do:</p> <pre><code>import nix_shell\nshell = nix_shell.from_nix(\"shell.nix\", args={\n  \"pythonVersion\": os.environ.get(\"PYTHON_VERSION\", \"python313\"),\n  \"env\": {\n    \"MY_FLAG\": os.environ.get(\"MY_FLAG\", \"\")\n  }\n})\n</code></pre> <p>This is then passed as an argument to your <code>shell.nix</code>:</p> <pre><code>{ pkgs, pythonVersion, env }:\npkgs.mkShell {\n  packages = [ pkgs.${pythonVersion} ];\n  shellHook = ''\n    export MY_FLAG='${env.MY_FLAG}'\n  '';\n}\n</code></pre> <p>To disable this behavior, pass <code>impure=True</code>:</p> <pre><code>nix = nix_shell.from_nix(\"/path/to/your/shell.nix\", impure=True)\n</code></pre> <p>Be warned that certain caching features are not guaranteed to work in impure mode.</p>"},{"location":"advanced/#nixpkgs-version-locking","title":"<code>nixpkgs</code> version locking","text":"<p>NOTE: This does not apply to <code>from_flake</code>, which uses only input versions from your <code>flake.lock</code>.</p> <p>In order to support pure evaluation, <code>py-nix-shell</code> directly manages the version of <code>nixpkgs</code> you use. You can control this behavior by passing the following:</p> <ul> <li>default behavior: Uses the version specified in this project's flake.lock. The package is updated weekly so that you can automatically keep your <code>nixpkgs</code> version up-to-date if needed.</li> <li><code>use_global_nixpkgs=True</code>: If you'd prefer to use the version of   <code>nixpkgs</code> the user has locally, you can specify <code>use_global_nixpkgs</code>   command. This extracts the <code>nixpkgs</code> version from <code>nix flake   metadata nixpkgs</code>.</li> <li><code>flake_lock=Path(\"./to/your/flake.lock\")</code>: You may also use a   <code>flake.lock</code> file. This will check for a <code>nixpkgs</code> entry and use   that version. If your <code>flake.lock</code> keeps its <code>nixpkgs</code> version under   a different name, you can use   <code>flake_lock_name=\"alternative_nixpkgs\"</code> to specify.</li> </ul>"},{"location":"advanced/#file-sets","title":"File sets","text":"<p>Because Nix doesn't really provide a means of purely managing many Nix files beyond version tracking like Git, <code>py-nix-shell</code> does provide a layer to supplement this functionality:</p> <pre><code>shell = nix_shell.from_fileset(\n  main=\"shell.nix\",\n  files=Path.cwd().glob(\"**.nix\")\n)\n</code></pre> <p>This is useful when you might have dev shells inside a Nix package that do not necessarily need the entire Git repository to update the shell. This can save on load times, especially since many shells do not necessarily depend on the full contents of a repository.</p> <pre><code>{ pkgs }:\nlet\n  myPackage = pkgs.callPackage ./my-package.nix {};\nin pkgs.mkShell { packages = [ myPackage ]; }\n</code></pre>"},{"location":"builders/","title":"Builders","text":"<p>While <code>nix_shell</code> can act as a very minimal layer on top of a generic <code>shell.nix</code>, it has the ability to build generic shells using a variety of methods to best meet your needs.</p>"},{"location":"builders/#mk_shell","title":"mk_shell","text":"<p>Provisions a Nix shell programatically via Python. For example, something like</p> <pre><code>nix = nix_shell.mk_shell(\n    packages=[\"curl\", \"openssl\"],\n    library_path=[\"stdenv.cc.cc.lib\"],\n    shell_hook=\"echo 'Hello world!'\",\n)\n</code></pre> <p>would be equivalent to the following <code>shell.nix</code>:</p> <pre><code>{ pkgs ? import &lt;nixpkgs&gt; {} }:\npkgs.mkShell {\n  packages = with pkgs; [ curl openssl ];\n  shellHook = ''\n    export LD_LIBRARY_PATH=${pkgs.lib.makeLibraryPath [ pkgs.stdenv.cc.cc.lib ]}:$LD_LIBRARY_PATH\n    echo 'Hello world!'\n  '';\n}\n</code></pre> <p>This enables you to quickly and dynamically provision shells whenever needed.</p>"},{"location":"builders/#from_nix","title":"from_nix","text":"<p>Provisions a Nix shell from a <code>shell.nix</code> file.</p> <pre><code>from nix_shell import from_nix\n\nnix = from_nix(nix_file=\"/path/to/your/shell.nix\")\n\n# This runs inside the given Nix shell\nnix.run([\"curl\", \"https://google.com\"])\n</code></pre>"},{"location":"builders/#from_flake","title":"from_flake","text":"<p>Provisions a Nix shell from a Flake output.</p> <pre><code>from nix_shell import from_flake\n\n# if you don't specify the particular output we will assume it is devShells.default\nnix = from_flake(flake=\"path:/to/your/flake.nix\")\n\n# but you can specify alternatives\nnix = from_flake(flake=\"path:/to/your/flake.nix#devShells.alternate\")\n</code></pre>"},{"location":"builders/#advanced-usage","title":"Advanced Usage","text":""},{"location":"builders/#pure-evaluation","title":"Pure evaluation","text":"<p>By default, all Nix shell evaluations in <code>py-nix-shell</code> are pure. This means that generally your <code>shell.nix</code> files can't access user envirnonment variables, and you can't access other files on the filesystem from Nix.</p> <p>In order to disable this behavior, you can pass <code>impure=True</code>:</p> <pre><code>nix = nix_shell.from_nix(\"/path/to/your/shell.nix\", impure=True)\n</code></pre>"},{"location":"builders/#nixpkgs-version-locking","title":"<code>nixpkgs</code> version locking","text":"<p>This is specific only to <code>mk_shell</code> and <code>from_nix</code>. <code>from_flake</code> only uses the <code>nixpkgs</code> version as specified in the `flake.lock file.</p> <p>In order to support pure evaluation, <code>py-nix-shell</code> direclty manages the version of <code>nixpkgs</code> you use. You can control this behavior by passing the following:</p> <ul> <li>default behavior: Uses the version specified in this project's flake.lock. The package is updated weekly so that you can automatically keep your <code>nixpkgs</code> version up-to-date if needed.</li> <li><code>use_global_nixpkgs=True</code>: If you'd prefer to use the version of   <code>nixpkgs</code> the user has locally, you can specify <code>use_global_nixpkgs</code>   command. This extracts the <code>nixpkgs</code> version from <code>nix flake   metadata nixpkgs</code>.</li> <li><code>flake_lock=Path(\"./to/your/flake.lock\")</code>: You may also use a   <code>flake.lock</code> file. This will check for a <code>nixpkgs</code> entry and use   that version. If your <code>flake.lock</code> keeps its <code>nixpkgs</code> version under   a different name, you can use   <code>flake_lock_name=\"alternative_nixpkgs\"</code> to specify.</li> </ul>"},{"location":"index-old/","title":"py-nix-shell","text":"<p>Invoke commands inside Nix shells from Python using the familiar <code>subprocess</code> interface.</p>"},{"location":"index-old/#features","title":"Features","text":"<ul> <li>Easy to use: Commands that use <code>subprocess.run</code> can be easily   migrated -- simply swap <code>subprocess.run</code> with <code>nix_shell.run</code> and   you're good to go.</li> <li>Supports non-Nix users: Folks without Nix can still use this,   and get helpful error messages describing what they need to install   or instructions for installing Nix.</li> <li>Customizable: You can manage your Shell environments with flakes, a shell.nix, or even through Python</li> </ul>"},{"location":"index-old/#installation","title":"Installation","text":"<pre><code>pip install nix-shell\n</code></pre>"},{"location":"index-old/#getting-started","title":"Getting Started","text":"<p>See the docs for more details, but</p> <pre><code>import nix_shell\n\n# nix_shell supports existing subprocess commands\n\n# if the command name matches the `nixpkgs` name, install that by default\nnix_shell.run([\"curl\", \"https://google.com\", \"--insecure\"])\n\n# you can manually specify nix packages to install\nnix_shell.run([\"curl\", \"https://google.com\"], packages=[\"curl\", \"openssl\"])\n\n# use a dev environment from a flake\nnix_shell.run([\"curl\", \"https://google.com\"], flake=\"github:chadac/py-nix-shell#sample-curl-env\")\n\n# or, just use the `nixpkgs` version from a `flake.lock` file\nnix_shell.run([\"curl\", \"https://google.com\"], packages=[\"curl\", \"openssl\"], flake_lock=Path(\"./my/flake.lock\"))\n</code></pre> <p>You can use <code>run</code>, <code>check_output</code>, <code>Popen</code>, <code>call</code>, <code>check_call</code>, <code>getoutput</code> and <code>getstatusoutput</code>.</p> <p>If you want to run a bunch of commands under the same environment, you can use the following:</p> <pre><code>import nix_shell\n\n# build a shell manually\nnix = nix_shell.mk_shell(packages=[\"curl\"], library_path=[\"stdenv.cc.cc.lib\"])\n\n# specify a shell.nix file to use\nnix = nix_shell.from_nix(\"path:/to/my/shell.nix\")\n\n# specify a flake to use\nnix = nix_shell.from_flake(\"path:/to/my/flake.nix#devShells.default\")\n\nnix.run([\"curl\", \"https://google.com\"])\n</code></pre>"},{"location":"api/_nix/","title":"_nix","text":"<p>Interface for invoking the Nix CLI from Python.</p>"},{"location":"api/_nix/#nix_shell._nix.NixBuildArgs","title":"NixBuildArgs","text":"<p>               Bases: <code>TypedDict</code></p> <p>Common arguments passed to commands like <code>nix build</code>.</p> <p>Mostly \"Common evaluation options\" and \"Options that change the interpretation of installables\".</p> <p>Either <code>file</code> + <code>installable</code>, <code>ref</code> or <code>expr</code> are required.</p> <p>Parameters:</p> Name Type Description Default <code>file</code> <code>Path | str</code> <p>Equivalent to <code>--file</code>.</p> required <code>installable</code> <code>str</code> <p>Path to installable if <code>--file</code> is specified.</p> required <code>ref</code> <code>str</code> <p>Flake reference to build.</p> required <code>expr</code> <code>str</code> <p>Nix expression to build.</p> required <code>impure</code> <code>bool</code> <p>Whether to run nix in impure evaluation mode. Defaults to <code>False</code>.</p> required <code>include</code> <code>tuple[tuple[str, str]]</code> <p>Equivalent to <code>--include</code>.</p> required"},{"location":"api/_nix/#nix_shell._nix.derivation","title":"derivation","text":""},{"location":"api/_nix/#nix_shell._nix.derivation.show","title":"show  <code>staticmethod</code>","text":"<pre><code>show(**params: Unpack[NixBuildArgs])\n</code></pre> <p>Run <code>nix derivation show</code></p>"},{"location":"api/_nix/#nix_shell._nix.flake","title":"flake","text":""},{"location":"api/_nix/#nix_shell._nix.flake.metadata","title":"metadata  <code>staticmethod</code>","text":"<pre><code>metadata(flake_ref: str) -&gt; dict\n</code></pre> <p>Run <code>nix flake metadata</code></p>"},{"location":"api/_nix/#nix_shell._nix.build","title":"build","text":"<pre><code>build(\n    out_link: Path | None = None,\n    no_link: bool = False,\n    print_out_paths: bool = False,\n    **params: Unpack[NixBuildArgs],\n)\n</code></pre> <p>Run <code>nix build</code></p>"},{"location":"api/_nix/#nix_shell._nix.current_system","title":"current_system  <code>cached</code>","text":"<pre><code>current_system() -&gt; str\n</code></pre> <p>The current system according to <code>nix</code>.</p> <p>This returns the result of <code>nix eval --impure --raw 'builtins.currentSystem'</code>.</p>"},{"location":"api/_nix/#nix_shell._nix.evaluate","title":"evaluate","text":"<pre><code>evaluate(raw: bool = True, **params: Unpack[NixBuildArgs])\n</code></pre> <p>Run <code>nix eval</code></p> <p>Named <code>evaluate</code> because <code>eval</code> is a reserved word in Python.</p>"},{"location":"api/_nix/#nix_shell._nix.impure_nixpkgs_path","title":"impure_nixpkgs_path  <code>cached</code>","text":"<pre><code>impure_nixpkgs_path() -&gt; str\n</code></pre> <p>Return the path of the current <code>nixpkgs</code> channel.</p> <p>This grabs the result of <code>nix eval --impure '&lt;nixpkgs&gt;'</code></p>"},{"location":"api/build/","title":"Build","text":""},{"location":"api/build/#nix_shell.build.NixBuild","title":"NixBuild  <code>dataclass</code>","text":"<p>Wrapper for <code>nix build</code> commands with some convenient utilities.</p>"},{"location":"api/build/#nix_shell.build.NixBuild.build_id","title":"build_id  <code>cached</code> <code>property</code>","text":"<pre><code>build_id: str\n</code></pre> <p>Identifier for the build.</p> <p>Useful for distinguishing pure builds.</p>"},{"location":"api/build/#nix_shell.build.NixBuild.save_link","title":"save_link","text":"<pre><code>save_link(dest: Path) -&gt; None\n</code></pre> <p>Creates a symlink to the derivation at the given location.</p>"},{"location":"api/build/#nix_shell.build.NixShell","title":"NixShell  <code>dataclass</code>","text":"<p>               Bases: <code>NixBuild</code></p> <p>Nix derivations that are made via <code>mkShell</code>.</p>"},{"location":"api/build/#nix_shell.build.NixShell.script_path","title":"script_path  <code>property</code>","text":"<pre><code>script_path: str\n</code></pre> <p>Path to script that activates shell.</p>"},{"location":"api/build/#nix_shell.build.NixShell.Popen","title":"Popen","text":"<pre><code>Popen(*args, **kwargs) -&gt; Popen[str] | Popen[bytes]\n</code></pre> <p>See subprocess.Popen</p>"},{"location":"api/build/#nix_shell.build.NixShell.activate","title":"activate","text":"<pre><code>activate() -&gt; None\n</code></pre> <p>Activates a Nix shell inside the given Python session.</p>"},{"location":"api/build/#nix_shell.build.NixShell.call","title":"call","text":"<pre><code>call(*args, **kwargs) -&gt; int\n</code></pre> <p>See subprocess.call</p>"},{"location":"api/build/#nix_shell.build.NixShell.check_call","title":"check_call","text":"<pre><code>check_call(*args, **kwargs) -&gt; int\n</code></pre> <p>See subprocess.check_call</p>"},{"location":"api/build/#nix_shell.build.NixShell.check_output","title":"check_output","text":"<pre><code>check_output(*args, **kwargs) -&gt; bytes | str\n</code></pre> <p>See subprocess.check_output</p>"},{"location":"api/build/#nix_shell.build.NixShell.getoutput","title":"getoutput","text":"<pre><code>getoutput(*args, **kwargs) -&gt; str\n</code></pre> <p>See subprocess.getoutput</p>"},{"location":"api/build/#nix_shell.build.NixShell.getstatusoutput","title":"getstatusoutput","text":"<pre><code>getstatusoutput(*args, **kwargs) -&gt; tuple[int, str]\n</code></pre> <p>See subprocess.getstatusoutput</p>"},{"location":"api/build/#nix_shell.build.NixShell.run","title":"run","text":"<pre><code>run(\n    *args, **kwargs\n) -&gt; CompletedProcess[bytes] | CompletedProcess[str]\n</code></pre> <p>See subprocess.run</p>"},{"location":"api/builders/","title":"builders","text":""},{"location":"api/builders/#nix_shell.builders.FlakeRefParams","title":"FlakeRefParams","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters to provide for building Flake shells.</p> <p>Parameters:</p> Name Type Description Default <code>flake</code> <code>str</code> <p>The Flake reference URL. See the Nix docs for more details</p> required"},{"location":"api/builders/#nix_shell.builders.MkNixParams","title":"MkNixParams","text":"<p>               Bases: <code>NixpkgsParams</code></p> <p>Parameters for building a shell from a <code>shell.nix</code> file.</p> <p>Parameters:</p> Name Type Description Default <code>nix_file</code> <code>Path | str</code> <p>Path to the <code>shell.nix</code> file.</p> required"},{"location":"api/builders/#nix_shell.builders.MkShellParams","title":"MkShellParams","text":"<p>               Bases: <code>NixpkgsParams</code></p> <p>Parameters for dynamically building a shell from Python.</p> <p>Parameters:</p> Name Type Description Default <code>packages</code> <code>list[str]</code> <p>List of <code>nixpkgs</code> packages to install. (default: <code>[]</code>)</p> required <code>inputs_from</code> <code>list[str]</code> <p>List of <code>nixpkgs</code> packages to use inputs from. (default: <code>[]</code>)</p> required <code>build_inputs</code> <code>list[str]</code> <p>List of <code>nixpkgs</code> packages to use as build inputs. (default: <code>[]</code>)</p> required <code>library_path</code> <code>list[str]</code> <p>List of <code>nixpkgs</code> packages to add to the LD_LIBRARY_PATH. (default: <code>[]</code>)</p> required <code>shell_hook</code> <code>str</code> <p>Additional (bash) initialization commands to run once the shell initializes. (default: <code>\"\"</code>)</p> required <code>system</code> <code>str</code> <p>The system to build for. The default is the current system that <code>py-nix-shell</code> is running on.</p> required"},{"location":"api/builders/#nix_shell.builders.NixpkgsParams","title":"NixpkgsParams","text":"<p>               Bases: <code>TypedDict</code></p> <p>Parameters to customize where <code>nixpkgs</code> is sourced from.</p> <p>Parameters:</p> Name Type Description Default <code>nixpkgs</code> <code>str</code> <p>If present, the flake reference URL for the <code>nixpkgs</code> version</p> required <code>use_global_nixpkgs</code> <code>bool</code> <p>If true, uses the <code>nixpkgs</code> version from the local flake registry (<code>nix flake metadata nixpkgs</code>). (default: <code>False</code>)</p> required <code>flake_lock</code> <code>Path | str</code> <p>If present, uses the <code>nixpkgs</code> version from a <code>flake.lock</code> file provided at the given path.</p> required <code>flake_lock_name</code> <code>str</code> <p>The name of the <code>nixpkgs</code> entry in the <code>flake.lock</code> file (default: <code>nixpkgs</code>)</p> required"},{"location":"api/builders/#nix_shell.builders.from_flake","title":"from_flake","text":"<pre><code>from_flake(**kwargs: Unpack[FlakeRefParams]) -&gt; NixShell\n</code></pre> <p>Create a Nix shell from a flake.</p>"},{"location":"api/builders/#nix_shell.builders.from_nix","title":"from_nix","text":"<pre><code>from_nix(**kwargs: Unpack[MkNixParams]) -&gt; NixShell\n</code></pre> <p>Create a Nix shell from a <code>shell.nix</code> file.</p>"},{"location":"api/builders/#nix_shell.builders.mk_shell","title":"mk_shell","text":"<pre><code>mk_shell(**kwargs: Unpack[MkShellParams]) -&gt; NixShell\n</code></pre> <p>Create a Nix shell dynamically from Python.</p>"},{"location":"api/builders/#nix_shell.builders.mk_shell_expr","title":"mk_shell_expr","text":"<pre><code>mk_shell_expr(**kwargs: Unpack[MkShellParams]) -&gt; str\n</code></pre> <p>Generate the <code>shell.nix</code> expresssion for <code>mk_shell</code></p>"},{"location":"api/builders/#nix_shell.builders.parse_nixpkgs_tree","title":"parse_nixpkgs_tree","text":"<pre><code>parse_nixpkgs_tree(\n    **kwargs: Unpack[NixpkgsParams],\n) -&gt; dict[str, NixValue]\n</code></pre> <p>Determine the version of <code>nixpkgs</code> to use.</p>"},{"location":"api/constants/","title":"constants","text":""},{"location":"api/constants/#nix_shell.constants.CACHE_ROOT","title":"CACHE_ROOT  <code>module-attribute</code>","text":"<pre><code>CACHE_ROOT = expanduser() / 'py-nix-shell'\n</code></pre> <p>Location of the cache directory used for persisting some shells.</p>"},{"location":"api/constants/#nix_shell.constants.PKG_FLAKE_LOCK","title":"PKG_FLAKE_LOCK  <code>module-attribute</code>","text":"<pre><code>PKG_FLAKE_LOCK = parent / 'flake.lock'\n</code></pre> <p>Path to the <code>flake.lock</code> file distributed with the project.</p>"},{"location":"api/exceptions/","title":"exceptions","text":""},{"location":"api/flake/","title":"flake","text":"<p>Utilities for working with Flakes.</p>"},{"location":"api/flake/#nix_shell.flake.get_impure_nixpkgs_ref","title":"get_impure_nixpkgs_ref","text":"<pre><code>get_impure_nixpkgs_ref() -&gt; dict\n</code></pre> <p>Get a locked reference to the version of <code>nixpkgs</code> from the local Nix channel.</p>"},{"location":"api/flake/#nix_shell.flake.get_ref_from_lockfile","title":"get_ref_from_lockfile","text":"<pre><code>get_ref_from_lockfile(\n    flake_lock: Path | str, nixpkgs: str = \"nixpkgs\"\n) -&gt; dict[str, NixValue]\n</code></pre> <p>Grabs the locked reference for a given node from a <code>flake.lock</code>.</p> <p>Parameters:</p> Name Type Description Default <code>flake_lock</code> <code>Path | str</code> <p>The path to the <code>flake.lock</code> file.</p> required <code>nixpkgs</code> <code>str</code> <p>The name of the node to grab.</p> <code>'nixpkgs'</code>"},{"location":"api/flake/#nix_shell.flake.to_fetch_tree","title":"to_fetch_tree","text":"<pre><code>to_fetch_tree(ref: FlakeRef) -&gt; dict[str, NixValue]\n</code></pre> <p>Convert a flake reference into a proper locked reference.</p> <p>Flake URLs are often not reproducible; however, the result of this is properly hashed and reproducible.</p>"},{"location":"api/nixlang/","title":"nixlang","text":"<p>Deserializer for Nix language constructs.</p>"},{"location":"api/root/","title":"Root","text":""},{"location":"api/root/#nix_shell.from_flake","title":"from_flake","text":"<pre><code>from_flake(**kwargs: Unpack[FlakeRefParams]) -&gt; NixShell\n</code></pre> <p>Create a Nix shell from a flake.</p>"},{"location":"api/root/#nix_shell.from_nix","title":"from_nix","text":"<pre><code>from_nix(**kwargs: Unpack[MkNixParams]) -&gt; NixShell\n</code></pre> <p>Create a Nix shell from a <code>shell.nix</code> file.</p>"},{"location":"api/root/#nix_shell.mk_shell","title":"mk_shell","text":"<pre><code>mk_shell(**kwargs: Unpack[MkShellParams]) -&gt; NixShell\n</code></pre> <p>Create a Nix shell dynamically from Python.</p>"},{"location":"usage/shell.py/","title":"Shell.py","text":""},{"location":"usage/shell.py/#shellpy","title":"shell.py","text":"<p><code>py-nix-shell</code> provides an interface for quickly building new Nix shells using Python syntax via the <code>py-nix-shell</code> CLI utility.</p> <p>Usage is simple; using the same builders specified above, if you export it as a global variable named <code>shell</code> you can use it with <code>py-nix-shell</code>:</p> <pre><code>import nix_shell\nshell = nix_shell.mk_shell(\n  packages=[\"curl\", \"uv\"]\n)\n</code></pre> <p>Shells can be activated similar to the <code>nix</code> syntax:</p> <pre><code># activates the `shell.py` in the given directory\npy-nix-shell\n\n# activates an alternative `shell.py`\npy-nix-shell activate alternate_shell.py\n\n# prints the dev environment for a given shell, useful for direnv\npy-nix-shell print-dev-env\n</code></pre>"},{"location":"usage/subprocess/","title":"subprocess substitution","text":"<p><code>py-nix-shell</code> provisions Nix shells in one of three ways: via a <code>shell.nix</code>, a Nix flake, or programatically via Python.</p> <p>The most basic invocation is via <code>nix_shell.run</code>:</p> <pre><code>nix_shell.run([\"uv\", \"run\", \"--\", \"pytest\"])\n</code></pre> <p>This automatically installs <code>uv</code> from <code>nixpkgs</code> and uses that to invoke <code>pytest</code>.</p> <p>You may also manually specify packages to include:</p> <pre><code>nix_shell.check_output([\"make\", \"test\"], packages=[\"uv\", \"gnumake\", \"python312\"])\n</code></pre> <p>If you already have a <code>shell.nix</code> or <code>flake.nix</code>, it's possible to activate these environments as well:</p> <pre><code>nix_shell.call([\"curl\", \"http://localhost:8080\"], nix_file=Path(\"/to/your/shell.nix\"))\n\nnix_shell.Popen([\"curl\", \"http://localhost:8080\"], flake=Path(\"/to/your/flake/project\"))\nnix_shell.Popen([\"curl\", \"http://localhost:8080\"], flake=\"github:your/flake-project\")\n</code></pre> <p>If you need to invoke multiple commands in sequence, you can also generate a reusable shell in three ways:</p>"}]}